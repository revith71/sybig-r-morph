<!-- templates/index.html -->
<!DOCTYPE html>
<html lang="en">
<head>
  <div class="logo-container" style="text-align: center; width: 100%; margin: 20px 0;">
  <img src="{{ url_for('static', filename='images/logo.png') }}" 
       alt="SyBig-r-Morph Logo" 
       class="logo" 
       style="max-width: 150px; height: auto;">
</div>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>SyBig-r-Morph</title>
    <link href="https://cdn.jsdelivr.net/npm/bootstrap@5.3.0-alpha1/dist/css/bootstrap.min.css" rel="stylesheet">
    <link rel="stylesheet" href="{{ url_for('static', filename='css/style.css') }}">
    <style>
        body {
            padding: 20px;
            font-family: 'Arial', sans-serif;
        }
        .container {
            max-width: 800px;
        }
        .status-box {
            height: 200px;
            overflow-y: auto;
            border: 1px solid #ddd;
            padding: 10px;
            margin-bottom: 20px;
            background-color: #f9f9f9;
        }
        .results-box {
            height: 300px;
            overflow-y: auto;
            border: 1px solid #ddd;
            padding: 10px;
            background-color: #f9f9f9;
        }
        .pseudoword {
            font-size: 18px;
            padding: 5px 10px;
            margin: 5px;
            display: inline-block;
            background-color: #fcbfbb;
            border-radius: 5px;
            border: 1px solid #FF645A;
            cursor: grab; /* Show grab cursor to indicate draggable */
            transition: transform 0.1s, box-shadow 0.1s;
        }
        .pseudoword.dragging {
            opacity: 0.8;
            transform: scale(1.05);
            box-shadow: 0 2px 10px rgba(0,0,0,0.2);
            cursor: grabbing;
            z-index: 100;
        }
        .pseudoword-container {
            min-height: 50px;
            padding: 10px;
        }
        .loading {
            display: none;
            margin-top: 20px;
        }
        .status-message {
            margin-bottom: 5px;
            font-size: 14px;
        }
        .status-time {
            color: #666;
            font-size: 12px;
            margin-right: 8px;
        }
        
        /* Visual indicator for drag-and-drop functionality */
        .reorder-help {
            font-size: 12px;
            color: #666;
            margin-bottom: 10px;
            font-style: italic;
        }
        
        /* Add space for ordering buttons */
        .word-controls {
            display: flex;
            justify-content: space-between;
            margin-bottom: 10px;
        }
        
        .word-actions button {
            margin-left: 5px;
            font-size: 0.8rem;
        }
      
        .status-message:contains("Lexicons loaded successfully"),
        .alert:contains("Lexicons loaded successfully"),
        .status-box .status-message:contains("Lexicons loaded"),
        .status-message.success {
            color: #0f5132 !important; /* Dark green text */
            border-color: #009AB2 !important; 
            font-weight: bold;
            background-color: #e6f7f9 !important; /* Light teal background */
        }
        
        /* Color of warning alert text box */
        .alert-warning, 
        div[class*="warning"],
        div[class*="alert"] {
            color: #fcbfbb !important;
            border-color: #FF645A !important;
            /* Removed duplicate color declaration */
            font-weight: bold !important;
            background-color: #fff0f0 !important;
        }
        
        /* Error message styling */
        .alert-danger,
        .status-message.error,
        .status-message:contains("ERROR:") {
            color: #842029 !important;
            background-color: #f8d7da !important;
            border-color: #f5c2c7 !important;
            font-weight: bold !important;
        }
        
        /* Success alert dark green */
        .status-message.success,
        .alert-success,
        div[class*="success"] {
            color: #037385 !important; 
            border-color: #009AB2 !important;
            font-weight: bold !important;
            background-color: #e6f7f9 !important;
        }
        
        .alert-success,
        .alert.alert-success {
            color: #037385 !important; /* Dark green */
        }
        
        /* Button colors */
        .btn-primary {
            background-color: #009AB2 !important; 
            border-color: #0296ad !important;
            color: white !important;
        }
        .btn-primary:hover, 
        .btn-primary:active,
        .btn-primary:focus,
        .btn-primary.active {
            background-color: #009AB2 !important;
            border-color: #0296ad !important;
            color: white !important;
        }
        
        /* Button colors (CORAL) */
        .btn-success {
            background-color: #FF645A !important; /* Coral */
            border-color: #eb5950 !important;
            color: white !important;
        }
        .btn-success:hover,
        .btn-success:active,
        .btn-success:focus,
        .btn-success.active {
            background-color: #FF645A !important;
            border-color: #eb5950 !important;
            color: white !important;
        }
        
        /* For Webkit browsers (Chrome, Safari) */
        input[type=range]::-webkit-slider-thumb {
          background-color:#FF645A !important; 
          border: 2px solid #eb5950 !important;
        }
        
        /* For Firefox */
        input[type=range]::-moz-range-thumb {
          background-color: #FF645A !important;
          border: 2px solid #eb5950 !important;
        }
        
        /* For IE/Edge */
        input[type=range]::-ms-thumb {
          background-color: #FF645A !important; 
          border: 2px solid #eb5950 !important;
        }
        
        /* Style for the value displays */
        #freq_threshold_value,
        #sim_threshold_value {
          display: inline-block;
          padding: 2px 6px;
          background-color: #fff;
          border: 1px solid #ccc;
          border-radius: 3px;
          font-weight: bold;
          min-width: 30px;
          text-align: center;
        }
        
        /* If you want to match the coral color theme */
        #freq_threshold_value,
        #sim_threshold_value {
          border-color: #FF645A;
          background-color: #fff;
          color: #000;
        }
        
        /* Target only the Copy All and Download CSV buttons */
        .card-header a.btn-outline-light,
        .card-header button.btn-outline-light {
            color: white !important;
            background-color: transparent !important;
            border-color: white !important;
        }
        
        /* Target specific buttons with more precise selectors */
        .btn-copy-all, 
        .copy-all-button,
        .btn-download-csv,
        .download-csv-button,
        #copy-all,
        #download-csv {
            color: white !important;
        }
        
        /* Ensure the text stays white even on hover/focus states */
        .card-header .btn:hover,
        .card-header .btn:active,
        .card-header .btn:focus {
            color: white !important;
        }
        
        /* Target the specific buttons in your card header */
        .card-header .btn {
            color: white !important;
            background-color: transparent !important;
            border-color: white !important;
        }
        
        /* Specifically target buttons by their text content */
        button:contains("CSV"), 
        a:contains("CSV"),
        button:contains("Download CSV"),
        a:contains("Download CSV"),
        button:contains("Copy All"),
        a:contains("Copy All") {
            color: white !important;
            background-color: transparent !important;
            border-color: white !important;
        }
        
        /* Also target likely class names */
        .btn-copy-all, .btn-download-csv {
            color: white !important;
            background-color: transparent !important;
            border-color: white !important;
        }
        
        .card-header {
            background-color: #009AB2 !important;
            color: white !important;
            border-color: #0296ad !important;
        }
        
        /* Alert box for lexicon errors */
        #lexicon-error-alert {
            display: none;
            margin-bottom: 15px;
            padding: 10px 15px;
            color: #842029 !important;
            background-color: #f8d7da !important;
            border: 1px solid #f5c2c7 !important;
            border-radius: 5px;
        }

        /* Syllable selection container */
        .syllable-selector {
            max-height: 200px;
            overflow-y: auto;
            border: 1px solid #ddd;
            padding: 10px;
            margin-top: 10px;
            margin-bottom: 20px;
            background-color: #f9f9f9;
            display: none; /* Hidden by default */
        }

        /* Syllable selection item */
        .syllable-item {
            display: inline-block;
            margin: 3px;
            padding: 5px 10px;
            background-color: #4BA3B8; /* Teal/blue color when selected */
            border: 1px solid #409aaf;
            color: white;
            border-radius: 3px;
            cursor: pointer;
        }

        /* Add this style for non-selected state */
        .syllable-item:not(.selected) {
            background-color: white; /* White background when deselected */
            color: #333; /* Dark text color for better visibility */
            border-color: #409aaf; /* Keep the same border color */
        }

        /* Keep the same style for selected state */
        .syllable-item.selected {
            background-color: #4BA3B8;
            color: white;
            border-color: #409aaf;
        }
        
        /* Make status text color match "Deselect All" button */
        #syllable-status {
            color: #6c757d !important; /* Bootstrap's default gray for text-muted */
        }
        
        /* Update the show/hide button hover state */
        #show-syllables-btn:hover,
        #show-syllables-btn:active,
        #show-syllables-btn:focus,
        #select-all-syllables:hover,
        #select-all-syllables:active,
        #select-all-syllables:focus {
            background-color: #eb5950 !important;
            border-color: #d45148 !important;
        }
        
        /* Custom checkbox styling for green color */
        .form-check-input:checked {
            background-color: #009AB2 !important; /* Bootstrap success green */
            border-color: #009AB2 !important;
        }
        
        .form-check-input:focus {
            border-color: #009AB2 !important;
            box-shadow: 0 0 0 0.2rem rgba(40, 167, 69, 0.25) !important;
        }
        
        /* For WebKit browsers (Safari, Chrome) - custom checkbox appearance */
        .form-check-input[type="checkbox"] {
            -webkit-appearance: none;
            -moz-appearance: none;
            appearance: none;
            width: 1.125rem;
            height: 1.125rem;
            border: 1px solid #dee2e6;
            border-radius: 0.25rem;
            background-color: #fff;
            background-repeat: no-repeat;
            background-position: center;
            background-size: contain;
        }
        
        .form-check-input[type="checkbox"]:checked {
            background-color: #009AB2 !important;
            border-color: #009AB2 !important;
            background-image: url("data:image/svg+xml,%3csvg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 20 20'%3e%3cpath fill='none' stroke='%23fff' stroke-linecap='round' stroke-linejoin='round' stroke-width='3' d='m6 10 3 3 6-6'/%3e%3c/svg%3e") !important;
        }
        
        .form-check-input[type="checkbox"]:indeterminate {
            background-color: #009AB2 !important;
            border-color: #009AB2 !important;
        }
        
        /* Keep helper text on one line - more specific selector */
        .col-md-8 .form-text.text-muted {
            white-space: nowrap !important;
            overflow: hidden;
            text-overflow: ellipsis;
        }
        
        /* Alternative: make the container wider for the stress section */
        .row .col-md-8 {
            flex: 0 0 100% !important;
            max-width: 100% !important;
        }
        
        /* Make the Apply Greek Stress Rules button coral */
        #apply-stress-rules-btn {
            background-color: #FF645A !important; /* Coral */
            border-color: #eb5950 !important;
            color: white !important;
        }
        #apply-stress-rules-btn:hover,
        #apply-stress-rules-btn:active,
        #apply-stress-rules-btn:focus,
        #apply-stress-rules-btn.active {
            background-color: #eb5950 !important;
            border-color: #d45148 !important;
            color: white !important;
        }
        
        /* Add space between Generated Pseudowords and Stress Assignment sections */
        #stress-section {
            margin-top: 20px !important;
        }
    </style>
</head>
<body>
    <div class="container">
        <h1 class="mb-4">SyBig-r-Morph</h1>
        
        <!-- Lexicon Loading Section -->
        <div class="card mb-4">
            <div class="card-header">
                <h5>Lexicon Status</h5>
            </div>
            <div class="card-body">
                <!-- Error Alert Box -->
                <div id="lexicon-error-alert"></div>
                
                <div id="lexicon-status" class="mb-3">
                    {% if lexicons_loaded %}
                        <div class="alert alert-success">
                            Lexicons loaded successfully
                        </div>
                    {% else %}
                        <div class="alert alert-warning">
                            Lexicons not loaded. Please click the button below to load lexicons.
                        </div>
                    {% endif %}
                </div>
                <button id="load-lexicons" class="btn btn-primary" {% if lexicons_loaded %}disabled{% endif %}>
                    Load Lexicons
                </button>
            </div>
        </div>
        
        <!-- Generation Parameters -->
        <div class="card mb-4">
            <div class="card-header">
                <h5>Generation Parameters</h5>
            </div>
            <div class="card-body">
                <form id="generation-form">
                    <div class="row mb-3">
                        <div class="col-md-6">
                            <label for="postype" class="form-label">Part of Speech:</label>
                            <select id="postype" name="postype" class="form-select" {% if not lexicons_loaded %}disabled{% endif %}>
                                {% if lexicons_loaded %}
                                    <option value="all">All</option>
                                    {% set allowed_pos = ["noun", "verb", "adj", "adv", "prep"] %}
                                    {% for pos in available_pos %}
                                        {% if pos in allowed_pos %}
                                            {% set display_name = {
                                                "noun": "Noun", 
                                                "verb": "Verb", 
                                                "adj": "Adjective", 
                                                "adv": "Adverb", 
                                                "prep": "Preposition"
                                            }.get(pos, pos) %}
                                            <option value="{{ pos }}">{{ display_name }}</option>
                                        {% endif %}
                                    {% endfor %}
                                {% endif %}
                            </select>
                        </div>
                        <div class="col-md-6">
                            <label for="num_syllables" class="form-label">Number of Syllables:</label>
                            <select id="num_syllables" name="num_syllables" class="form-select">
                                <option value="1">1</option>
                                <option value="2">2</option>
                                <option value="3" selected>3</option>
                                <option value="4">4</option>
                                <option value="5">5</option>
                            </select>
                        </div>
                    </div>
                    
                    <div class="row mb-3">
                        <div class="col-md-6">
                            <label for="freq_threshold" class="form-label">Frequency Threshold:</label>
                            <input type="range" class="form-range" id="freq_threshold" name="freq_threshold" 
                                min="1.327" max="7.533" step="0.001" value="4.327">
                            <div class="d-flex justify-content-between">
                                <small class="text-muted">Less frequent</small>
                                <small id="freq_threshold_value">5.0</small>
                                <small class="text-muted">More frequent</small>
                            </div>
                        </div>
                        <div class="col-md-6">
                            <label for="sim_threshold" class="form-label">Similarity Threshold:</label>
                            <input type="range" class="form-range" id="sim_threshold" name="sim_threshold" 
                                min="0.0" max="1.0" step="0.1" value="0.8">
                            <div class="d-flex justify-content-between">
                                <small class="text-muted">Less similar</small>
                                <small id="sim_threshold_value">0.8</small>
                                <small class="text-muted">More similar</small>
                            </div>
                        </div>
                    </div>
                    
                    <!-- Last Syllable Selection Section -->
                    <div class="mb-3">
                        <label class="form-label">Last Syllable Selection:</label>
                        <div class="d-flex align-items-center">
                            <button type="button" id="show-syllables-btn" class="btn me-3" 
                                    style="background-color: #FF645A; border-color: #eb5950; color: white;" 
                                    {% if not lexicons_loaded %}disabled{% endif %}>
                                Show Available Last Syllables
                            </button>
                            <span id="syllable-status" class="small" style="color: #6c757d;">No syllables selected</span>
                        </div>
                        <div id="syllable-selector" class="syllable-selector">
                            <div class="mb-2 d-flex justify-content-between">
                                <div>
                                    <button type="button" id="select-all-syllables" class="btn btn-sm" 
                                            style="background-color: #FF645A; border-color: #eb5950; color: white;">
                                        Select All
                                    </button>
                                    <button type="button" id="deselect-all-syllables" class="btn btn-sm btn-outline-secondary"
                                            style="background-color: #f8f9fa; border-color: #ced4da; color: #6c757d;">
                                        Deselect All
                                    </button>
                                </div>
                                <div>
                                    <input type="text" id="search-syllables" class="form-control form-control-sm" placeholder="Search syllables...">
                                </div>
                            </div>
                            <div id="syllable-list" class="mt-2">
                                <!-- Syllables will be loaded here -->
                                <p class="text-center">Loading syllables...</p>
                            </div>
                        </div>
                    </div>
                    
                    <div class="mb-3">
                        <label for="max_words" class="form-label">Number of Words:</label>
                        <input type="number" class="form-control" id="max_words" name="max_words" 
                            min="1" max="1000" value="20">
                    </div>
                    
                    <button type="submit" class="btn btn-success" id="generate-btn" {% if not lexicons_loaded %}disabled{% endif %}>
                        Generate Pseudowords
                    </button>
                </form>
            </div>
        </div>
        
        <!-- Loading Indicator -->
        <div class="loading text-center" id="loading">
            <div class="spinner-border text-primary" role="status">
                <span class="visually-hidden">Loading...</span>
            </div>
            <p class="mt-2">Generating pseudowords... This may take a moment.</p>
        </div>
        
        <!-- Status and Results -->
        <div class="card mb-4">
            <div class="card-header">
                <h5>Status</h5>
            </div>
            <div class="card-body">
                <div class="status-box" id="status-box"></div>
            </div>
        </div>
        
        <div class="card">
            <div class="card-header d-flex justify-content-between align-items-center">
                <h5>Generated Pseudowords</h5>
                <div>
                    <button id="sort-alpha-btn" class="btn btn-sm btn-outline-light" disabled>
                        Sort A-Z
                    </button>
                    <button id="sort-random-btn" class="btn btn-sm btn-outline-light" disabled>
                        Randomize
                    </button>
                    <button id="copy-btn" class="btn btn-sm btn-outline-light" disabled>
                        Copy All
                    </button>
                    <button id="download-csv-btn" class="btn btn-sm btn-outline-light ms-2" disabled>
                        Download CSV
                    </button>
                </div>
            </div>
            <div class="card-body">
                <div class="word-controls">
                    <div class="reorder-help">
                        <i class="bi bi-info-circle"></i> Drag and drop words to reorder them.
                    </div>
                </div>
                <div class="results-box" id="results-box">
                    <div class="pseudoword-container" id="pseudoword-container"></div>
                </div>
            </div>
        </div>
        
        <!-- Stress Assignment Section -->
        <div class="card mb-4" id="stress-section">
            <div class="card-header">
                <h5>Stress Assignment</h5>
            </div>
            <div class="card-body">
                <!-- Input area for words -->
                <div class="mb-3">
                    <label class="form-label">Greek Words (one per line):</label>
                    <textarea id="stress-input" class="form-control" rows="6" 
                        placeholder="Paste your pseudowords here or click 'Import Generated Words'"></textarea>
                </div>
                
                <!-- Stress options -->
                <div class="row mb-3">
                    <div class="col-md-8">
                        <label class="form-label">Stress Pattern:</label>
                        <div class="form-check">
                            <input class="form-check-input" type="checkbox" id="stress-antepenult" value="antepenult">
                            <label class="form-check-label" for="stress-antepenult">
                                Antepenult (APU) - third to last syllable
                            </label>
                        </div>
                        <div class="form-check">
                            <input class="form-check-input" type="checkbox" id="stress-penult" value="penult">
                            <label class="form-check-label" for="stress-penult">
                                Penult (PU) - second to last syllable
                            </label>
                        </div>
                        <div class="form-check">
                            <input class="form-check-input" type="checkbox" id="stress-ultima" value="ultima">
                            <label class="form-check-label" for="stress-ultima">
                                Ultima (U) - last syllable
                            </label>
                        </div>
                        <small class="form-text text-muted mt-2">
                            Multiple selections: Use 'Apply Greek Stress Rules'. Single selection: Use 'Apply Stress'.
                        </small>
                    </div>
                </div>
                
                <!-- Action buttons -->
                <div class="mb-3">
                    <button id="import-words-btn" class="btn btn-outline-secondary" disabled>
                        Import Generated Words
                    </button>
                    <button id="apply-stress-rules-btn" class="btn btn-primary" disabled>
                        Apply Greek Stress Rules
                    </button>
                    <button id="apply-stress-btn" class="btn btn-success" disabled>
                        Apply Stress
                    </button>
                    <button id="clear-stress-btn" class="btn btn-outline-secondary">
                        Clear
                    </button>
                </div>
                
                <!-- Results -->
                <div class="mb-3">
                    <label class="form-label">Stressed Words:</label>
                    <textarea id="stress-output" class="form-control" rows="6" readonly 
                        placeholder="Stressed words will appear here..."></textarea>
                </div>
                
                <!-- Export options -->
                <div>
                    <button id="copy-stressed-btn" class="btn btn-outline-secondary" disabled>
                        Copy Stressed Words
                    </button>
                    <button id="download-stressed-csv-btn" class="btn btn-outline-secondary" disabled>
                        Download Stressed CSV
                    </button>
                </div>
            </div>
        </div>
    </div>
    
    <script src="https://cdn.jsdelivr.net/npm/bootstrap@5.3.0-alpha1/dist/js/bootstrap.bundle.min.js"></script>
    <script>
        document.addEventListener('DOMContentLoaded', function() {
            // Elements
            const loadLexiconsBtn = document.getElementById('load-lexicons');
            const generateForm = document.getElementById('generation-form');
            const generateBtn = document.getElementById('generate-btn');
            const statusBox = document.getElementById('status-box');
            const resultsBox = document.getElementById('results-box');
            const pseudowordContainer = document.getElementById('pseudoword-container');
            const loading = document.getElementById('loading');
            const copyBtn = document.getElementById('copy-btn');
            const downloadCsvBtn = document.getElementById('download-csv-btn');
            const sortAlphaBtn = document.getElementById('sort-alpha-btn');
            const sortRandomBtn = document.getElementById('sort-random-btn');
            const freqThreshold = document.getElementById('freq_threshold');
            const freqThresholdValue = document.getElementById('freq_threshold_value');
            const simThreshold = document.getElementById('sim_threshold');
            const simThresholdValue = document.getElementById('sim_threshold_value');
            const lexiconErrorAlert = document.getElementById('lexicon-error-alert');
            
            // New elements for the syllable selection feature
            const showSyllablesBtn = document.getElementById('show-syllables-btn');
            const syllableSelector = document.getElementById('syllable-selector');
            const syllableList = document.getElementById('syllable-list');
            const syllableStatus = document.getElementById('syllable-status');
            const selectAllSyllablesBtn = document.getElementById('select-all-syllables');
            const deselectAllSyllablesBtn = document.getElementById('deselect-all-syllables');
            const searchSyllablesInput = document.getElementById('search-syllables');
            
            // Stress assignment elements
            const stressInput = document.getElementById('stress-input');
            const stressOutput = document.getElementById('stress-output');
            const importWordsBtn = document.getElementById('import-words-btn');
            const applyStressRulesBtn = document.getElementById('apply-stress-rules-btn');
            const applyStressBtn = document.getElementById('apply-stress-btn');
            const clearStressBtn = document.getElementById('clear-stress-btn');
            const copyStressedBtn = document.getElementById('copy-stressed-btn');
            const downloadStressedCsvBtn = document.getElementById('download-stressed-csv-btn');
            const stressAntepenultCheck = document.getElementById('stress-antepenult');
            const stressPenultCheck = document.getElementById('stress-penult');
            const stressUltimaCheck = document.getElementById('stress-ultima');
            
            // Store available last syllables
            let availableLastSyllables = [];
            let selectedLastSyllables = [];
            
            // Drag and drop functionality
            let draggedItem = null;
            
            // Function to apply Greek stress rules automatically
            function applyGreekStressRules() {
                const pseudowords = Array.from(document.querySelectorAll('#pseudoword-container .pseudoword'))
                    .map(el => el.textContent);
                
                if (pseudowords.length === 0) {
                    addStatusMessage('No pseudowords to apply stress to. Please generate pseudowords first.', 'error');
                    return;
                }
                
                // Get the current part of speech selection
                const partOfSpeech = document.getElementById('postype').value;
                
                // Show loading
                loading.style.display = 'block';
                addStatusMessage('Applying Greek stress rules...');
                
                // Send request to apply stress
                fetch('/apply_stress_rules', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                    },
                    body: JSON.stringify({
                        words: pseudowords,
                        part_of_speech: partOfSpeech
                    })
                })
                .then(response => response.json())
                .then(data => {
                    loading.style.display = 'none';
                    
                    if (data.success) {
                        // Update the stress input area with the stressed words
                        stressInput.value = data.stressed_words.join('\n');
                        
                        // Also update the stress output to show the stressed words
                        stressOutput.value = data.stressed_words.join('\n');
                        
                        // Enable the export buttons for stressed words
                        copyStressedBtn.disabled = false;
                        downloadStressedCsvBtn.disabled = false;
                        
                        addStatusMessage(`Applied Greek stress rules to ${data.stressed_words.length} pseudowords using part of speech: ${partOfSpeech}`, 'success');
                        
                        // Update status if provided
                        if (data.status && data.status.length > 0) {
                            updateStatus(data.status);
                        }
                    } else {
                        addStatusMessage('Error applying stress rules: ' + data.message, 'error');
                    }
                })
                .catch(error => {
                    loading.style.display = 'none';
                    addStatusMessage('Error applying stress rules: ' + error.message, 'error');
                });
            }
            
            // Greek stress assignment functionality
            function countSyllables(word) {
                // Greek vowels (including diphthongs)
                const vowels = /[αεηιοωυάέήίόώύΐΰ]/g;
                const diphthongs = /[αεο][ιυ]|[ηω][υ]|υι/g;
                
                // Count vowel groups, treating diphthongs as single syllables
                let syllableCount = 0;
                let processedWord = word.toLowerCase();
                
                // First, mark diphthongs
                const diphthongMatches = [...processedWord.matchAll(diphthongs)];
                let diphthongPositions = [];
                diphthongMatches.forEach(match => {
                    for (let i = match.index; i < match.index + match[0].length; i++) {
                        diphthongPositions.push(i);
                    }
                });
                
                // Count vowels that aren't part of diphthongs
                for (let i = 0; i < processedWord.length; i++) {
                    if (vowels.test(processedWord[i]) && !diphthongPositions.includes(i)) {
                        syllableCount++;
                    }
                }
                
                // Add diphthongs as single syllables
                syllableCount += diphthongMatches.length;
                
                return Math.max(1, syllableCount); // Ensure at least 1 syllable
            }
            
            function findVowelPositions(word) {
                const vowels = /[αεηιοωυάέήίόώύΐΰ]/;
                const diphthongs = /[αεο][ιυ]|[ηω][υ]|υι/g;
                
                let positions = [];
                let processedWord = word.toLowerCase();
                
                // Find diphthongs first
                const diphthongMatches = [...processedWord.matchAll(diphthongs)];
                let diphthongRanges = [];
                diphthongMatches.forEach(match => {
                    diphthongRanges.push({start: match.index, end: match.index + match[0].length - 1});
                    positions.push(match.index); // Position of the diphthong (first character)
                });
                
                // Find individual vowels that aren't part of diphthongs
                for (let i = 0; i < processedWord.length; i++) {
                    if (vowels.test(processedWord[i])) {
                        let isInDiphthong = diphthongRanges.some(range => i >= range.start && i <= range.end);
                        if (!isInDiphthong) {
                            positions.push(i);
                        }
                    }
                }
                
                return positions.sort((a, b) => a - b);
            }
            
            function addStressToWord(word, position) {
                // Remove any existing stress marks first
                let cleanWord = word.replace(/[άέήίόώύΐΰ]/g, (match) => {
                    const stressMap = {
                        'ά': 'α', 'έ': 'ε', 'ή': 'η', 'ί': 'ι', 'ό': 'ο', 'ώ': 'ω', 'ύ': 'υ',
                        'ΐ': 'ι', 'ΰ': 'υ'
                    };
                    return stressMap[match] || match;
                });
                
                const vowelPositions = findVowelPositions(cleanWord);
                const syllableCount = vowelPositions.length;
                
                if (syllableCount === 0) return word;
                
                let targetSyllable;
                
                // Determine which syllable to stress based on position
                switch(position) {
                    case 'ultima':
                        targetSyllable = syllableCount - 1;
                        break;
                    case 'penult':
                        targetSyllable = Math.max(0, syllableCount - 2);
                        break;
                    case 'antepenult':
                        targetSyllable = Math.max(0, syllableCount - 3);
                        break;
                    default:
                        return word;
                }
                
                // For words with fewer syllables than required, default to first syllable
                if (targetSyllable >= syllableCount) {
                    targetSyllable = 0;
                }
                
                const vowelIndex = vowelPositions[targetSyllable];
                
                // Check if this vowel is part of a diphthong and handle accordingly
                const stressedWord = applyStressAtPosition(cleanWord, vowelIndex);
                return stressedWord;
            }
            
            function applyStressAtPosition(word, vowelIndex) {
                const diphthongs = {
                    'αι': 'αί', 'ει': 'εί', 'οι': 'οί', 
                    'αυ': 'αύ', 'ευ': 'εύ', 'ηυ': 'ηύ', 
                    'ου': 'ού', 'υι': 'υί'
                };
                
                let result = word.split('');
                const lowerWord = word.toLowerCase();
                
                // Check if this vowel is the start of a diphthong
                for (let [diphthong, stressedDiphthong] of Object.entries(diphthongs)) {
                    if (vowelIndex < lowerWord.length - 1 && 
                        lowerWord.slice(vowelIndex, vowelIndex + 2) === diphthong) {
                        // Replace the diphthong with its stressed version
                        result[vowelIndex] = stressedDiphthong[0];
                        result[vowelIndex + 1] = stressedDiphthong[1];
                        return result.join('');
                    }
                }
                
                // Check if this vowel is the second part of a diphthong
                if (vowelIndex > 0) {
                    for (let [diphthong, stressedDiphthong] of Object.entries(diphthongs)) {
                        if (lowerWord.slice(vowelIndex - 1, vowelIndex + 1) === diphthong) {
                            // Replace the diphthong with its stressed version
                            result[vowelIndex - 1] = stressedDiphthong[0];
                            result[vowelIndex] = stressedDiphthong[1];
                            return result.join('');
                        }
                    }
                }
                
                // If not part of a diphthong, apply single vowel stress
                const vowelChar = lowerWord[vowelIndex];
                const stressMap = {
                    'α': 'ά', 'ε': 'έ', 'η': 'ή', 'ι': 'ί', 'ο': 'ό', 'ω': 'ώ', 'υ': 'ύ'
                };
                
                if (stressMap[vowelChar]) {
                    result[vowelIndex] = stressMap[vowelChar];
                }
                
                return result.join('');
            }
            
            function applyStressToWords() {
                const inputText = stressInput.value.trim();
                if (!inputText) {
                    addStatusMessage('No words to stress', 'error');
                    return;
                }
                
                // Get selected stress positions
                const selectedPositions = [];
                if (stressAntepenultCheck.checked) selectedPositions.push('antepenult');
                if (stressPenultCheck.checked) selectedPositions.push('penult');
                if (stressUltimaCheck.checked) selectedPositions.push('ultima');
                
                if (selectedPositions.length === 0) {
                    addStatusMessage('Please select at least one stress position', 'error');
                    return;
                }
                
                const words = inputText.split('\n').filter(word => word.trim() !== '');
                const stressedWords = [];
                
                words.forEach((word, index) => {
                    const cleanWord = word.trim();
                    if (!cleanWord) return;
                    
                    const syllableCount = countSyllables(cleanWord);
                    let stressPosition;
                    
                    if (selectedPositions.length === 1) {
                        // Single position selected
                        stressPosition = selectedPositions[0];
                    } else {
                        // Multiple positions selected - distribute evenly
                        if (syllableCount === 2) {
                            // For 2-syllable words, use 50-50 distribution between ultima and penult
                            const validPositions = selectedPositions.filter(pos => 
                                pos === 'ultima' || pos === 'penult'
                            );
                            if (validPositions.length > 0) {
                                stressPosition = validPositions[index % validPositions.length];
                            } else {
                                stressPosition = selectedPositions[index % selectedPositions.length];
                            }
                        } else {
                            // For 3+ syllable words, distribute evenly among all selected positions
                            stressPosition = selectedPositions[index % selectedPositions.length];
                        }
                    }
                    
                    const stressedWord = addStressToWord(cleanWord, stressPosition);
                    stressedWords.push(stressedWord);
                });
                
                stressOutput.value = stressedWords.join('\n');
                
                // Enable export buttons
                copyStressedBtn.disabled = false;
                downloadStressedCsvBtn.disabled = false;
                
                addStatusMessage(`Applied stress to ${stressedWords.length} words using ${selectedPositions.join(', ')} distribution`);
            }
            
            function addDragListeners(element) {
                element.setAttribute('draggable', 'true');
                
                element.addEventListener('dragstart', function(e) {
                    draggedItem = this;
                    setTimeout(() => this.classList.add('dragging'), 0);
                    
                    // Set data for drag operation
                    e.dataTransfer.effectAllowed = 'move';
                    e.dataTransfer.setData('text/plain', this.textContent);
                });
                
                element.addEventListener('dragend', function() {
                    this.classList.remove('dragging');
                    draggedItem = null;
                });
            }
            
            // Setup the pseudoword container for drop events
            pseudowordContainer.addEventListener('dragover', function(e) {
                e.preventDefault();
                e.dataTransfer.dropEffect = 'move';
                
                const afterElement = getDragAfterElement(this, e.clientY);
                
                if (draggedItem) {
                    if (afterElement) {
                        this.insertBefore(draggedItem, afterElement);
                    } else {
                        this.appendChild(draggedItem);
                    }
                }
            });
            
            pseudowordContainer.addEventListener('drop', function(e) {
                e.preventDefault();
                // The actual movement is handled in dragover
                addStatusMessage("Word order updated");
            });
            
            // Determine where to insert the dragged element
            function getDragAfterElement(container, y) {
                const draggableElements = [...container.querySelectorAll('.pseudoword:not(.dragging)')];
                
                return draggableElements.reduce((closest, child) => {
                    const box = child.getBoundingClientRect();
                    const offset = y - box.top - box.height / 2;
                    
                    if (offset < 0 && offset > closest.offset) {
                        return { offset: offset, element: child };
                    } else {
                        return closest;
                    }
                }, { offset: Number.NEGATIVE_INFINITY }).element;
            }
            
            // Update range value displays with 2 decimal places
            freqThreshold.addEventListener('input', function() {
                // Get the raw value
                const value = parseFloat(this.value);
                
                // Format with 2 decimal places
                freqThresholdValue.textContent = value.toFixed(2);
            });

            simThreshold.addEventListener('input', function() {
                // Get the raw value
                const value = parseFloat(this.value);
                
                // Always show at least 1 decimal place
                simThresholdValue.textContent = value.toFixed(1);
            });
            
            // Function to fetch available syllables
            function fetchAvailableSyllables() {
                const postype = document.getElementById('postype').value;
                const numSyllables = document.getElementById('num_syllables').value;
                const freqThreshold = document.getElementById('freq_threshold').value;
                
                // Show loading state
                syllableList.innerHTML = '<p class="text-center">Loading syllables...</p>';
                
                // Create form data
                const formData = new FormData();
                formData.append('postype', postype);
                formData.append('num_syllables', numSyllables);
                formData.append('freq_threshold', freqThreshold);
                
                // Send request to server
                fetch('/get_syllables', {
                    method: 'POST',
                    body: formData
                })
                .then(response => response.json())
                .then(data => {
                    if (data.success) {
                        // Store available syllables
                        availableLastSyllables = data.last_syllables || [];
                        // Initially select all syllables
                        selectedLastSyllables = [...availableLastSyllables];
                        
                        // Update syllable status
                        updateSyllableStatus();
                        
                        // Generate syllable selection interface
                        renderSyllableList();
                        
                        // Update status messages if they were returned
                        if (data.status && data.status.length > 0) {
                            updateStatus(data.status);
                        }
                    } else {
                        // Show error message
                        syllableList.innerHTML = `<p class="text-danger text-center">Error: ${data.message || 'Could not load syllables'}</p>`;
                        addStatusMessage('Error loading syllables: ' + (data.message || 'Unknown error'), 'error');
                        
                        // Update status messages if they were returned
                        if (data.status && data.status.length > 0) {
                            updateStatus(data.status);
                        }
                    }
                })
                .catch(error => {
                    syllableList.innerHTML = `<p class="text-danger text-center">Error: ${error.message}</p>`;
                    addStatusMessage('Error loading syllables: ' + error.message, 'error');
                });
            }
            
            // Function to update syllable status display
            function updateSyllableStatus() {
                if (selectedLastSyllables.length === 0) {
                    syllableStatus.textContent = 'No syllables selected';
                    syllableStatus.className = 'small text-danger';
                } else if (selectedLastSyllables.length === availableLastSyllables.length) {
                    syllableStatus.textContent = 'All syllables selected';
                    syllableStatus.className = 'small text-success';
                } else {
                    syllableStatus.textContent = `${selectedLastSyllables.length} of ${availableLastSyllables.length} syllables selected`;
                    syllableStatus.className = 'small text-primary';
                }
            }
            
            // Function to render the syllable selection list
            function renderSyllableList() {
                syllableList.innerHTML = '';
                
                // Get search term
                const searchTerm = searchSyllablesInput.value.toLowerCase();
                
                // Filter syllables based on search
                const filteredSyllables = availableLastSyllables.filter(syllable => 
                    syllable.toLowerCase().includes(searchTerm)
                );
                
                if (filteredSyllables.length === 0) {
                    syllableList.innerHTML = `<p class="text-center">No syllables match your search</p>`;
                    return;
                }
                
                // Create a syllable element for each filtered syllable
                filteredSyllables.forEach(syllable => {
                    const syllableElement = document.createElement('div');
                    syllableElement.className = 'syllable-item';
                    if (selectedLastSyllables.includes(syllable)) {
                        syllableElement.className += ' selected';
                    }
                    syllableElement.textContent = syllable;
                    syllableElement.dataset.syllable = syllable;
                    
                    // Add click event to toggle selection
                    syllableElement.addEventListener('click', function() {
                        toggleSyllableSelection(this);
                    });
                    
                    syllableList.appendChild(syllableElement);
                });
            }
            
            // Function to toggle syllable selection
            function toggleSyllableSelection(element) {
                const syllable = element.dataset.syllable;
                
                if (element.classList.contains('selected')) {
                    // Deselect
                    element.classList.remove('selected');
                    selectedLastSyllables = selectedLastSyllables.filter(s => s !== syllable);
                } else {
                    // Select
                    element.classList.add('selected');
                    selectedLastSyllables.push(syllable);
                }
                
                // Update status display
                updateSyllableStatus();
            }
            
            // Show available syllables when button is clicked
            showSyllablesBtn.addEventListener('click', function() {
                // Toggle visibility
                if (syllableSelector.style.display === 'block') {
                    syllableSelector.style.display = 'none';
                    showSyllablesBtn.textContent = 'Show Available Last Syllables';
                } else {
                    syllableSelector.style.display = 'block';
                    showSyllablesBtn.textContent = 'Hide Available Last Syllables';
                    
                    // Fetch available syllables if not already fetched or parameters changed
                    fetchAvailableSyllables();
                }
            });
            
            // Update syllables when parameters change
            document.getElementById('postype').addEventListener('change', function() {
                if (syllableSelector.style.display === 'block') {
                    fetchAvailableSyllables();
                }
            });
            
            document.getElementById('num_syllables').addEventListener('change', function() {
                if (syllableSelector.style.display === 'block') {
                    fetchAvailableSyllables();
                }
            });
            
            freqThreshold.addEventListener('change', function() {
                if (syllableSelector.style.display === 'block') {
                    fetchAvailableSyllables();
                }
            });
            
            // Handle select all and deselect all buttons
            selectAllSyllablesBtn.addEventListener('click', function() {
                selectedLastSyllables = [...availableLastSyllables];
                document.querySelectorAll('.syllable-item').forEach(item => {
                    item.classList.add('selected');
                });
                updateSyllableStatus();
            });
            
            deselectAllSyllablesBtn.addEventListener('click', function() {
                selectedLastSyllables = [];
                document.querySelectorAll('.syllable-item').forEach(item => {
                    item.classList.remove('selected');
                });
                updateSyllableStatus();
            });
            
            // Handle syllable search
            searchSyllablesInput.addEventListener('input', function() {
                renderSyllableList();
            });
            
            // Load Lexicons
            loadLexiconsBtn.addEventListener('click', function() {
                loadLexiconsBtn.disabled = true;
                statusBox.innerHTML = '<div class="status-message"><span class="status-time">' + 
                    getCurrentTime() + '</span>Loading lexicons, please wait...</div>';
                
                // Hide any previous error message
                lexiconErrorAlert.style.display = 'none';
                lexiconErrorAlert.textContent = '';
                
                fetch('/load_lexicons', {
                    method: 'POST'
                })
                .then(response => response.json())
                .then(data => {
                    if (data.success) {
                        document.getElementById('lexicon-status').innerHTML =
                            '<div class="alert alert-success">Lexicons loaded successfully</div>';
                                
                        // Update part of speech dropdown
                        const posSelect = document.getElementById('postype');
                        posSelect.innerHTML = '';
                        
                        // Create a mapping of original values to display names
                        const posMapping = {
                            "noun": "Noun",
                            "verb": "Verb",
                            "adj": "Adjective",
                            "adv": "Adverb",
                            "prep": "Preposition"
                        };
                        
                        // Define which POS to include (only these five)
                        const includedPos = ["noun", "verb", "adj", "adv", "prep"];
                        
                        // Filter and sort the available_pos array to only include our desired parts of speech
                        const filteredPos = data.available_pos.filter(pos => includedPos.includes(pos))
                            .sort((a, b) => {
                                return includedPos.indexOf(a) - includedPos.indexOf(b);
                            });
                        
                        // Add "All" option at the top
                        const allOption = document.createElement('option');
                        allOption.value = "all";
                        allOption.textContent = "All";
                        posSelect.appendChild(allOption);
                        
                        // Add the filtered options to the dropdown
                        filteredPos.forEach(pos => {
                            const option = document.createElement('option');
                            option.value = pos; // Keep original value for backend processing
                            option.textContent = posMapping[pos]; // Use mapped name
                            posSelect.appendChild(option);
                        });
                            
                        posSelect.disabled = false;
                        generateBtn.disabled = false;
                        showSyllablesBtn.disabled = false;
                        addStatusMessage('Lexicons loaded successfully', 'success');
                    } else {
                        // Show error message
                        document.getElementById('lexicon-status').innerHTML = 
                            '<div class="alert alert-danger">Error loading lexicons</div>';
                            
                        // Display error in the error alert box
                        lexiconErrorAlert.textContent = data.message;
                        lexiconErrorAlert.style.display = 'block';
                            
                        loadLexiconsBtn.disabled = false;
                        addStatusMessage('Error loading lexicons: ' + data.message, 'error');
                        
                        // Update status messages if they were returned
                        if (data.status && data.status.length > 0) {
                            updateStatus(data.status);
                        }
                    }
                })
                .catch(error => {
                    document.getElementById('lexicon-status').innerHTML = 
                        '<div class="alert alert-danger">Error loading lexicons: ' + error.message + '</div>';
                    loadLexiconsBtn.disabled = false;
                    addStatusMessage('Error loading lexicons: ' + error.message, 'error');
                });
            });
            
            // Generate Pseudowords
            generateForm.addEventListener('submit', function(e) {
                e.preventDefault();
                
                // Clear previous results
                pseudowordContainer.innerHTML = '';
                copyBtn.disabled = true;
                downloadCsvBtn.disabled = true;
                sortAlphaBtn.disabled = true;
                sortRandomBtn.disabled = true;
                
                // Show loading indicator
                loading.style.display = 'block';
                generateBtn.disabled = true;
                
                // Get form data
                const formData = new FormData(generateForm);
                
                // Add selected last syllables data
                formData.append('included_last_syllables', JSON.stringify(selectedLastSyllables));
                
                // Send request
                fetch('/generate', {
                    method: 'POST',
                    body: formData
                })
                .then(response => response.json())
                .then(data => {
                    // Hide loading indicator
                    loading.style.display = 'none';
                    generateBtn.disabled = false;
                    
                    // Update status
                    updateStatus(data.status);
                    
                    if (data.success) {
                        // Display results
                        if (data.pseudowords && data.pseudowords.length > 0) {
                            data.pseudowords.forEach((word, index) => {
                                const wordElement = document.createElement('div');
                                wordElement.className = 'pseudoword';
                                wordElement.textContent = word;
                                pseudowordContainer.appendChild(wordElement);
                                
                                // Add drag functionality
                                addDragListeners(wordElement);
                            });
                            
                            // Enable buttons
                            copyBtn.disabled = false;
                            downloadCsvBtn.disabled = false;
                            sortAlphaBtn.disabled = false;
                            sortRandomBtn.disabled = false;
                            importWordsBtn.disabled = false; // Enable import button when words are generated
                            applyStressRulesBtn.disabled = false; // Enable stress rules button when words are generated
                        } else {
                            pseudowordContainer.innerHTML = '<p>No pseudowords were generated. Try adjusting parameters.</p>';
                        }
                    } else {
                        // Show error message
                        addStatusMessage('Error: ' + data.message, 'error');
                        
                        // Display in error alert if it's a lexicon-related error
                        if (data.message.includes('lexicon') || data.message.includes('Lexicon')) {
                            lexiconErrorAlert.textContent = data.message;
                            lexiconErrorAlert.style.display = 'block';
                        }
                    }
                })
                .catch(error => {
                    // Hide loading indicator
                    loading.style.display = 'none';
                    generateBtn.disabled = false;
                    
                    // Show error
                    addStatusMessage('Error: ' + error.message, 'error');
                });
            });
            
            // Sort alphabetically
            sortAlphaBtn.addEventListener('click', function() {
                const words = Array.from(document.querySelectorAll('#pseudoword-container .pseudoword'));
                
                // Sort words alphabetically
                words.sort((a, b) => a.textContent.localeCompare(b.textContent));
                
                // Clear container
                pseudowordContainer.innerHTML = '';
                
                // Add words back in sorted order
                words.forEach(word => {
                    pseudowordContainer.appendChild(word);
                });
                
                addStatusMessage('Pseudowords sorted alphabetically');
            });
            
            // Randomize order
            sortRandomBtn.addEventListener('click', function() {
                const words = Array.from(document.querySelectorAll('#pseudoword-container .pseudoword'));
                
                // Fisher-Yates shuffle algorithm
                for (let i = words.length - 1; i > 0; i--) {
                    const j = Math.floor(Math.random() * (i + 1));
                    pseudowordContainer.insertBefore(words[j], words[i]);
                }
                
                addStatusMessage('Pseudowords randomly reordered');
            });
            
            // Copy all pseudowords
            copyBtn.addEventListener('click', function() {
                const pseudowords = Array.from(document.querySelectorAll('#pseudoword-container .pseudoword'))
                    .map(el => el.textContent)
                    .join('\n');
                
                navigator.clipboard.writeText(pseudowords).then(function() {
                    // Success
                    addStatusMessage('Copied all pseudowords to clipboard in current order');
                }, function() {
                    // Failure
                    addStatusMessage('Failed to copy pseudowords to clipboard', 'error');
                });
            });
            
            // Download CSV functionality
            downloadCsvBtn.addEventListener('click', function() {
                // Show loading
                loading.style.display = 'block';
                addStatusMessage('Preparing CSV download...');
                
                // Hide any previous error messages
                lexiconErrorAlert.style.display = 'none';
                
                // Get form data
                const formData = new FormData(generateForm);
                
                // Add current word order as a JSON string
                const currentWords = Array.from(document.querySelectorAll('#pseudoword-container .pseudoword'))
                    .map(el => el.textContent);
                
                // Add selected last syllables data
                formData.append('included_last_syllables', JSON.stringify(selectedLastSyllables));
                
                // Create a form submission for downloading with ordered words
                const form = document.createElement('form');
                form.method = 'POST';
                form.action = '/download_csv';
                
                // Add all form fields
                for (const [key, value] of formData.entries()) {
                    const input = document.createElement('input');
                    input.type = 'hidden';
                    input.name = key;
                    input.value = value;
                    form.appendChild(input);
                }
                
                // Add the current words as a hidden field
                const wordsInput = document.createElement('input');
                wordsInput.type = 'hidden';
                wordsInput.name = 'ordered_words';
                wordsInput.value = JSON.stringify(currentWords);
                form.appendChild(wordsInput);
                
                // Add to document, submit, and remove
                document.body.appendChild(form);
                form.submit();
                document.body.removeChild(form);
                
                // Hide loading after a delay
                setTimeout(() => {
                    loading.style.display = 'none';
                    addStatusMessage('CSV download initiated with current word order');
                }, 1000);
            });
            
            // Stress assignment event listeners
            importWordsBtn.addEventListener('click', function() {
                const pseudowords = Array.from(document.querySelectorAll('#pseudoword-container .pseudoword'))
                    .map(el => el.textContent);
                
                if (pseudowords.length === 0) {
                    addStatusMessage('No generated words to import. Please generate pseudowords first.', 'error');
                    return;
                }
                
                stressInput.value = pseudowords.join('\n');
                addStatusMessage(`Imported ${pseudowords.length} words for stress assignment`);
                
                // Enable apply stress button if at least one position is selected
                checkStressButtonState();
            });
            
            // Add event listener for the new stress rules button
            applyStressRulesBtn.addEventListener('click', applyGreekStressRules);
            
            function checkStressButtonState() {
                const hasWords = stressInput.value.trim() !== '';
                const hasSelectedPosition = stressAntepenultCheck.checked || 
                                          stressPenultCheck.checked || 
                                          stressUltimaCheck.checked;
                
                applyStressBtn.disabled = !(hasWords && hasSelectedPosition);
            }
            
            // Check stress button state when checkboxes change
            [stressAntepenultCheck, stressPenultCheck, stressUltimaCheck].forEach(checkbox => {
                checkbox.addEventListener('change', checkStressButtonState);
            });
            
            // Check stress button state when input changes
            stressInput.addEventListener('input', checkStressButtonState);
            
            applyStressBtn.addEventListener('click', function() {
                applyStressToWords();
            });
            
            clearStressBtn.addEventListener('click', function() {
                stressInput.value = '';
                stressOutput.value = '';
                copyStressedBtn.disabled = true;
                downloadStressedCsvBtn.disabled = true;
                checkStressButtonState();
                addStatusMessage('Stress assignment area cleared');
            });
            
            copyStressedBtn.addEventListener('click', function() {
                const stressedWords = stressOutput.value;
                if (!stressedWords.trim()) {
                    addStatusMessage('No stressed words to copy', 'error');
                    return;
                }
                
                navigator.clipboard.writeText(stressedWords).then(function() {
                    addStatusMessage('Copied stressed words to clipboard');
                }, function() {
                    addStatusMessage('Failed to copy stressed words to clipboard', 'error');
                });
            });
            
            downloadStressedCsvBtn.addEventListener('click', function() {
                const stressedWords = stressOutput.value.trim();
                if (!stressedWords) {
                    addStatusMessage('No stressed words to download', 'error');
                    return;
                }
                
                // Create CSV content
                const words = stressedWords.split('\n').filter(word => word.trim() !== '');
                let csvContent = '\ufeff'; // BOM for UTF-8
                csvContent += 'Stressed_Pseudoword\n';
                words.forEach(word => {
                    csvContent += `"${word.trim()}"\n`;
                });
                
                // Create and download file
                const blob = new Blob([csvContent], { type: 'text/csv;charset=utf-8;' });
                const link = document.createElement('a');
                const url = URL.createObjectURL(blob);
                link.setAttribute('href', url);
                
                const timestamp = new Date().toISOString().slice(0, 19).replace(/[:-]/g, '');
                link.setAttribute('download', `stressed_pseudowords_${timestamp}.csv`);
                
                document.body.appendChild(link);
                link.click();
                document.body.removeChild(link);
                
                addStatusMessage(`Downloaded CSV with ${words.length} stressed words`);
            });
            
            // Helper functions
            function getCurrentTime() {
                const now = new Date();
                return now.toLocaleTimeString();
            }
            
            function addStatusMessage(message, type = '') {
                const messageElement = document.createElement('div');
                messageElement.className = 'status-message';
                
                // Add type class if specified
                if (type) {
                    messageElement.classList.add(type);
                }
                
                // Make error messages more visible
                if (type === 'error' || message.includes('ERROR:') || message.includes('Error:')) {
                    messageElement.classList.add('error');
                }
                
                // Add success class for success messages
                if (type === 'success' || message.includes('successfully')) {
                    messageElement.classList.add('success');
                }
                
                messageElement.innerHTML = '<span class="status-time">' + getCurrentTime() + '</span>' + message;
                statusBox.appendChild(messageElement);
                statusBox.scrollTop = statusBox.scrollHeight;
            }
            
            function updateStatus(statusMessages) {
                if (statusMessages && statusMessages.length > 0) {
                    statusMessages.forEach(status => {
                        const messageElement = document.createElement('div');
                        messageElement.className = 'status-message';
                        
                        // Add error class for error messages
                        if (status.message.includes('ERROR:') || status.message.includes('Error:')) {
                            messageElement.classList.add('error');
                        }
                        
                        // Add success class for success messages
                        if (status.message.includes('success') || status.message.includes('Successfully')) {
                            messageElement.classList.add('success');
                        }
                        
                        messageElement.innerHTML = '<span class="status-time">' + status.time + '</span>' + status.message;
                        statusBox.appendChild(messageElement);
                    });
                    
                    // Scroll to the bottom
                    statusBox.scrollTop = statusBox.scrollHeight;
                }
            }
            
            // Add error listener for CSV download errors
            window.addEventListener('error', function(event) {
                if (event.target.tagName === 'FORM' && event.target.action.includes('/download_csv')) {
                    loading.style.display = 'none';
                    addStatusMessage('Error downloading CSV file. Please make sure lexicons are loaded.', 'error');
                }
            }, true);
        });
    </script>
</body>
</html>